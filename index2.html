<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Urban Maze Generator â€“ All Nodes Clickable</title>
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden;}
#map{width:100%;height:100%;}
.panel{
  position:absolute;
  top:10px;
  left:10px;
  background:rgba(0,0,0,0.75);
  color:white;
  padding:12px;
  border-radius:10px;
  font-family:sans-serif;
  font-size:14px;
}
.panel button{margin-top:6px;width:100%;}
</style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <div><b>Urban Maze</b></div>
  <div>Time: <span id="timer">0</span>s</div>
  <div>Moves: <span id="moves">0</span></div>
  <div>Best: <span id="best">-</span></div>
  <button onclick="newGame()">New Maze</button>
</div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoiZ2NhbXBpb25pIiwiYSI6ImNtbTJjanEzZDA1d3IycXM5b3poYjB5a2sifQ.pSXJk6Ul2mH1m9G8BSf12A';
const map = new mapboxgl.Map({
  container:'map',
  style:'mapbox://styles/mapbox/dark-v11',
  center:[12.4768,41.8895],
  zoom:15
});

const bbox="(41.883,12.466,41.895,12.485)";
let graph={}, nodesData={}, intersections=[], ways=[];
let currentNode=null, goalNode=null;
let moves=0, timer=0, timerInterval=null, bestScore=null;

// Load OSM
async function loadOSM(){
  const query = `
  [out:json];
  (
    way["highway"]["highway"!~"motorway|trunk|primary"]${bbox};
  );
  (._;>;);
  out body;
  `;
  const res = await fetch("https://overpass-api.de/api/interpreter",{method:"POST",body:query});
  const data = await res.json();
  processOSM(data);
}

function processOSM(data){
  const nodes={}, rawWays=[];
  data.elements.forEach(el=>{
    if(el.type==="node") nodes[el.id]=el;
    if(el.type==="way") rawWays.push(el);
  });
  nodesData = nodes;
  ways = rawWays;

  // Find intersections
  const count={};
  rawWays.forEach(w=>w.nodes.forEach(n=>count[n]=(count[n]||0)+1));
  intersections=Object.keys(count).filter(id=>count[id]>1);

  // Build graph including all nodes
  graph = {};
  Object.keys(nodes).forEach(id => graph[id.toString()] = []);
  ways.forEach(w=>{
    for(let i=0;i<w.nodes.length-1;i++){
      const a = w.nodes[i].toString();
      const b = w.nodes[i+1].toString();
      graph[a].push(b);
      graph[b].push(a);
    }
  });

  // GeoJSON for streets and nodes
  const streetsGeoJSON={type:"FeatureCollection",
    features:ways.map(w=>({type:"Feature",geometry:{type:"LineString",coordinates:w.nodes.map(id=>[nodes[id].lon,nodes[id].lat])}}))
  };

  const nodesGeoJSON={type:"FeatureCollection",
    features:Object.keys(nodes).map(id=>({type:"Feature",geometry:{type:"Point",coordinates:[nodes[id].lon,nodes[id].lat]},properties:{id:id}}))
  };

  map.addSource("streets",{type:"geojson",data:streetsGeoJSON});
  map.addLayer({id:"streets-layer",type:"line",source:"streets",paint:{"line-color":"#333","line-width":2}});

  map.addSource("nodes",{type:"geojson",data:nodesGeoJSON});
  map.addLayer({
    id:"nodes-layer",type:"circle",source:"nodes",
    paint:{
      "circle-color":["case",
        ["==", ["get","id"], currentNode], "#00ff00",
        ["==", ["get","id"], goalNode], "#ff0066",
        "#00ccff"
      ],
      "circle-radius":["case",
        ["==", ["get","id"], currentNode], 15,
        ["==", ["get","id"], goalNode], 15,
        8
      ],
      "circle-stroke-color":"#00ccff",
      "circle-stroke-width":1
    }
  }, "streets-layer");

  map.addSource("path",{type:"geojson",data:{type:"FeatureCollection",features:[]}});
  map.addLayer({id:"path-layer",type:"line",source:"path",paint:{"line-color":"#00ff88","line-width":4}});

  map.on("click","nodes-layer",handleMove);
  newGame();
}

function newGame(){
  clearInterval(timerInterval); timer=0; moves=0;
  document.getElementById("timer").innerText=timer;
  document.getElementById("moves").innerText=moves;

  currentNode = Object.keys(nodesData)[Math.floor(Math.random()*Object.keys(nodesData).length)].toString();
  goalNode = Object.keys(nodesData)[Math.floor(Math.random()*Object.keys(nodesData).length)].toString();
  while(goalNode===currentNode) goalNode = Object.keys(nodesData)[Math.floor(Math.random()*Object.keys(nodesData).length)].toString();

  highlightNodes();
  map.getSource("path").setData({type:"FeatureCollection",features:[]});

  timerInterval=setInterval(()=>{timer++;document.getElementById("timer").innerText=timer;},1000);
}

function highlightNodes(){
  map.setPaintProperty("nodes-layer","circle-color",[
    "case",
    ["==", ["get","id"], currentNode], "#00ff00",
    ["==", ["get","id"], goalNode], "#ff0066",
    "#00ccff"
  ]);
  map.setPaintProperty("nodes-layer","circle-radius",[
    "case",
    ["==", ["get","id"], currentNode], 15,
    ["==", ["get","id"], goalNode], 15,
    8
  ]);
}

function handleMove(e){
  const id = e.features[0].properties.id.toString();
  if(graph[currentNode].includes(id)){
    drawConnectionFullPath(currentNode,id);
    currentNode = id;
    moves++; document.getElementById("moves").innerText=moves;
    highlightNodes();
    if(currentNode===goalNode.toString()){
      clearInterval(timerInterval);
      alert("Maze Completed!");
      if(!bestScore || moves<bestScore){
        bestScore = moves; document.getElementById("best").innerText=bestScore;
      }
    }
  }
}

// Draw line along the shortest path (usually one edge) between currentNode and clicked node
function drawConnectionFullPath(a,b){
  // BFS along graph to find sequence of nodes
  const queue=[[a]];
  const visited=new Set([a]);
  let path=null;
  while(queue.length>0){
    const seq = queue.shift();
    const last = seq[seq.length-1];
    if(last===b){ path=seq; break; }
    graph[last].forEach(n=>{
      if(!visited.has(n)){
        visited.add(n);
        queue.push([...seq,n]);
      }
    });
  }
  if(!path) return;

  const coords = path.map(id=>[nodesData[id].lon,nodesData[id].lat]);
  map.getSource("path").setData({type:"FeatureCollection",features:[{type:"Feature",geometry:{type:"LineString",coordinates:coords}}]});
}

map.on("load",loadOSM);
</script>
</body>
</html>